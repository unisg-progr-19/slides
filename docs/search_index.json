[
["index.html", "7784 Skills: Programming in R 1 Introduction", " 7784 Skills: Programming in R Kirill Müller, Christoph Sax University of St. Gallen, HS 2019 1 Introduction Intro (Sept. 19): Slides Canvas Page "],
["visualization-and-reporting.html", "2 Visualization and Reporting", " 2 Visualization and Reporting Visualization and Reporting (Sept. 26): Slides "],
["data-tranformation-i.html", "3 Data Tranformation I", " 3 Data Tranformation I Data Tranformation I (Oct. 3): Slides "],
["data-tranformation-ii.html", "4 Data Tranformation II", " 4 Data Tranformation II Data Tranformation II (Oct. 10): Slides "],
["basics-of-r-base.html", "5 Basics of R base 5.1 The Main Data Structures 5.2 Introduction to Functions 5.3 Higher-Order Functions", " 5 Basics of R base Download as R script Intro Slides We have spent the first lessons of this course with dplyr and ggplot2, two of the great innovations in R universe of the last few years. If you were learning R 10 years ago, R would have looked quite differently. In this lesson, we cover the basics of R base - R (mostly) as it is before you load any packages. 5.1 The Main Data Structures R has four main data structures. In dplyr, we always work on data frames, or tibbles, the equivalent to an Excel sheet - a tabular collection of data. When performing operations, e.g., by using filter(), or mutate() we are performing operations on the columns of a data frame. These columns are vectors, and they are the heart of R. Related to them, matrices are basically two dimensional vectors that are useful in some mathematical or statistical applications. Finally, lists are the most versatile data type, and they are used in many circumstances. We will cover these data structures in the following order: vectors, matrices, lists and data frames, or tibbles (which we already know well). 5.1.1 Vectors, the R Workhorse The vector type is the most basic data structure in R. It’s hard to imagine R code that doesn’t involve vectors. If you use mutate to change columns of your data frame, you are effectively operating on vectors. The elements of a vector must all have the same class, or data type. You can have a vector consisting of three character strings (of class character) or three integer elements (of class integer), but not a vector with one integer element and two character string elements. 5.1.1.1 Vector Classes In many programming languages, vector variables are considered different from scalars, which are single-number variables. However, in R, numbers are actually considered one-element vectors, and there is really no such thing as a scalar. As we have seen previously, all elements of an R vector (or data frame column) must have the same class, which can be integer, numeric (also called double), character (string), logical (boolean). Here are some examples: x_log &lt;- c(TRUE, FALSE) # same as c(T, F) x_int &lt;- c(1L, 2L, 3L) # use 1L to enforce integer, rather than numeric x_num &lt;- c(1, 2, 6.3) # also called &#39;double&#39; x_chr &lt;- c(&quot;Hello World&quot;) If you need to check the class of a variable x, you can use, e.g.: class(x_log) ## [1] &quot;logical&quot; There is a certain order in the list above: logical is the least flexible class, while character is the most flexible. If you combine vectors of different classes, the more flexible class will win: class(c(x_log, x_num)) ## [1] &quot;numeric&quot; class(c(x_int, x_chr)) ## [1] &quot;character&quot; You can change the class of a vector with the following coercion functions. as.logical(c(1, 0)) ## [1] TRUE FALSE as.integer(c(1, 0)) ## [1] 1 0 as.numeric(c(&quot;1&quot;, &quot;2&quot;)) ## [1] 1 2 as.character(c(TRUE, FALSE)) ## [1] &quot;TRUE&quot; &quot;FALSE&quot; These functions will always work if you coerce towards greater flexibility. If you want to go the other way, it may give you NAs and some warnings: as.numeric(c(&quot;hi&quot;, &quot;number&quot;, &quot;1&quot;)) ## Warning: NAs introduced by coercion ## [1] NA NA 1 5.1.1.2 Recycling When applying an operation to two vectors that requires them to be the same length, R automatically recycles, or repeats, the shorter one, until it is long enough to match the longer one. Here is an example: c(1, 2) + c(6, 0, 9, 20, 22, 11) ## [1] 7 2 10 22 23 13 The shorter vector was recycled, so the operation was taken to be as follows: c(1, 2, 1, 2, 1, 2) + c(6, 0, 9, 20, 22, 11) ## [1] 7 2 10 22 23 13 The most common recycling operation involves a vector of length 1: c(6, 0, 9, 20, 22, 11) + 3 ## [1] 9 3 12 23 25 14 In dplyr, only a vector of length 1 is allowed to recycle, the other cases will result in an error. # tibble(a = c(1, 2), b = c(6, 0, 9, 20, 22, 11)) 5.1.1.3 Arithmetic Operators In R, every operator, including + in the following example, is actually a function. 2 + 3 ## [1] 5 The + here is a function with two arguments. A more functional way of writing it is the following: &quot;+&quot;(2, 3) ## [1] 5 Remember that scalars are actually one-element vectors. So, we can add vectors, and the + operation will be applied element-wise. x &lt;- c(1, 2, 4) x + c(5, 0, -1) ## [1] 6 2 3 The same is true, e.g., for multiplication, which is done element by element as well. (We will have a look at matrix multiplication in the next section.) x * c(5, 0, -1) ## [1] 5 0 -4 5.1.1.4 Comparison Operators Similar to arithmetic operators, comparison operators are applied element wise. The following expression will return a single TRUE, as we are comparing two vectors of length 1: 2 &gt; 1 ## [1] TRUE The comparison operator for ‘is equal to’ is ==, not =: 1 + 1 == 2 ## [1] TRUE Here is how they work on longer vectors: x &lt;- c(1, 2, 4, 2) y &lt;- c(2, 2, 4, 5) x == y ## [1] FALSE TRUE TRUE FALSE The usual recycling rules apply as well: x == 2 ## [1] FALSE TRUE FALSE TRUE Here are the other comparison operators: x &lt; y: less than x &lt;= y: less or equal than x &gt;= y: greater or equal than x != y: not equal Logical vectors can be combined by &amp; (AND) or | (OR): a &lt;- x &gt;= 2 b &lt;- x &lt; 4 a &amp; b ## [1] FALSE TRUE FALSE TRUE x &gt;= 4 | x &lt; 2 ## [1] TRUE FALSE TRUE FALSE 5.1.1.5 Indexing One of the most frequently used operations in R base is that of indexing vectors, in which we form a subvector by picking elements. You can use both integer values or logical vectors for indexing. 5.1.1.5.1 Indexing Using Integers We can extract values from a vector, using an integer index: y &lt;- c(1.2, 3.9, 0.4, 0.12) y[c(1, 3)] ## [1] 1.2 0.4 y[2:3] ## [1] 3.9 0.4 v &lt;- 3:4 y[v] ## [1] 0.40 0.12 Note that duplicates are allowed: y[c(1, 1, 3)] ## [1] 1.2 1.2 0.4 Negative subscripts mean that we want to exclude the elements: z &lt;- c(5, 12, 13) z[-1] ## [1] 12 13 z[-1:-2] ## [1] 13 5.1.1.5.2 Logical Indexing Logical indexing is perhaps even more important. Building on the example from above, we could also select element 1 and 3 in the following way: y &lt;- c(1.2, 3.9, 0.4, 0.12) y[c(FALSE, TRUE, FALSE, TRUE)] ## [1] 3.90 0.12 Logical indexing picks the TRUEs but not the FALSEs. This is the main building block for filtering. Suppose you have: y[y &gt; 1] ## [1] 1.2 3.9 This will return all elements that are bigger than 1. How is this done? First, R had evaluated the comparison, y &gt; 1, which led to logical vector: y &gt; 1 ## [1] TRUE TRUE FALSE FALSE Second, using logical indexing, this vector was then used to pick those elements that evaluated to TRUE. So y[y &gt; 1] is actually the same as: y[c(TRUE, TRUE, FALSE, TRUE)] ## [1] 1.20 3.90 0.12 We have already seen that you can assign to individual elements of a vector, using integer indices: y[c(2, 4)] &lt;- 5 Of course, you can do the same with logical indices: y[c(FALSE, TRUE, FALSE, TRUE)] &lt;- 5 This is a very powerful tool. For example, if you want to truncate all negative numbers in a vector to 0, you can use: z &lt;- c(-3, 1.2, 2, -22) z[z &lt; 0] &lt;- 0 Or use it with the %in% operator you encountered before: z[z %in% y] ## [1] 1.2 5.1.1.6 Exercises Create a vector called v1 containing the numbers 2, 5, 8, 12 and 16. Extract the values at positions 2 and 5 from v1. Use x:y notation to make a second vector called v2 containing the numbers 5 to 9. Subtract v2 from v1 and look at the result. Generate a vector with 1000 standard-normally distributed random numbers (use rnorm()). Store the result as v3. Extract the numbers that are bigger than 2. 5.1.2 Matrices An R matrix corresponds to the mathematical concept of the same name: a rectangular array of numbers (most of the time), or some other type. Here is some sample matrix code: m &lt;- matrix(c(1, 4, 2, 2), nrow = 2, ncol = 2) m ## [,1] [,2] ## [1,] 1 2 ## [2,] 4 2 The main use of matrices is for matrix algebra. You can do all kind of matrix algebra operations, right out of R base: m %*% m # matrix multiplication ## [,1] [,2] ## [1,] 9 6 ## [2,] 12 12 m * m # elementwise multiplication ## [,1] [,2] ## [1,] 1 4 ## [2,] 16 4 m %*% solve(m) # inverse of a matrix ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 1 m / m # elementwise division ## [,1] [,2] ## [1,] 1 1 ## [2,] 1 1 m + m ## [,1] [,2] ## [1,] 2 4 ## [2,] 8 4 m - m ## [,1] [,2] ## [1,] 0 0 ## [2,] 0 0 t(m) # matrix transpose ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 2 qr(m) # QR decomposition ## $qr ## [,1] [,2] ## [1,] -4.1231056 -2.425356 ## [2,] 0.9701425 -1.455214 ## ## $rank ## [1] 2 ## ## $qraux ## [1] 1.242536 1.455214 ## ## $pivot ## [1] 1 2 ## ## attr(,&quot;class&quot;) ## [1] &quot;qr&quot; det(m) # determinant ## [1] -6 eigen(m) # eigenvalues/eigenvectors ## eigen() decomposition ## $values ## [1] 4.372281 -1.372281 ## ## $vectors ## [,1] [,2] ## [1,] -0.5101065 -0.6445673 ## [2,] -0.8601113 0.7645475 diag(m) # diagonal ## [1] 1 2 Matrices are indexed by double subscripting: m[1, 2] ## [1] 2 m[2, 2] ## [1] 2 You can extract submatrices from a matrix, much as you extract subvectors from vectors: m[1, ] # row 1 ## [1] 1 2 m[1, , drop = FALSE] # keeps being a matrix ## [,1] [,2] ## [1,] 1 2 m[, 2] # column 2 ## [1] 2 2 5.1.2.1 Exercises Create a 10 x 10 matrix that contains a sequence of numbers (use the : notation). Use the transpose function on the matrix Extract the 2. column of the matrix Extract the 5. row of the matrix Extract the 5. and the 6. row of the matrix Compare the classes of the results in 3. and 4. to each other Modify 3., so that it returns the same class as 4. 5.1.3 Lists Like an R vector, an R list is a container for values, but its contents can be items of different data types, or different length. Here’s an example: x &lt;- list(u = c(2, 3, 4), v = &quot;abc&quot;) x ## $u ## [1] 2 3 4 ## ## $v ## [1] &quot;abc&quot; x$u ## [1] 2 3 4 The expression x$u refers to the u component in the list x. x[[&#39;u&#39;]] ## [1] 2 3 4 x[[1]] ## [1] 2 3 4 We can also refer to list components by their numerical indices. However, note that in this case, we use double brackets instead of single ones. We can also use single brackets rather than double brackets to get a subset of the list. x[&#39;u&#39;] ## $u ## [1] 2 3 4 x[1] ## $u ## [1] 2 3 4 x[1:2] ## $u ## [1] 2 3 4 ## ## $v ## [1] &quot;abc&quot; Note that x[[1]] returns the component (a numeric vector), while x[1] returns a subset of the list (a list of length 1): class(x[1]) ## [1] &quot;list&quot; class(x[[1]]) ## [1] &quot;numeric&quot; Hadley Wickham’s visualization helps a lot here: https://twitter.com/hadleywickham/status/643381054758363136 Lists are not restricted to containing vectors. In fact, they can contain anything, for example, a data frames: ll &lt;- list(mtcars = mtcars, u = c(2, 3, 4)) 5.1.3.1 Exercises Generate two random vectors of length 10, a, and b. Combine them in a list, call it l1. Compare the classes of l1[2] and l1[[2]]. Can you explain the difference? 5.1.4 Data Frames As we saw in many places, a typical data set contains data of different classes. Instead of a matrix, we use a data frame, or tibble. Technically, a data frame in R is a list, with each component of the list being a vector corresponding to a column in our data. You can create a data frame using tibble from tidyverse: library(tidyverse) d &lt;- tibble(kids = c(&quot;Jack&quot;, &quot;Jill&quot;), ages = c(12, 10)) d ## # A tibble: 2 x 2 ## kids ages ## &lt;chr&gt; &lt;dbl&gt; ## 1 Jack 12 ## 2 Jill 10 Here, I am using the tibble() function from tidyverse, rather than the R base equivalent, data.frame(). The reason for this is that data.frame() has some undesirable features, such as converting character vectors into factors. Because data frames are technically a list, we can access its vectors the same way as we access components of a list. d$ages ## [1] 12 10 d[[&#39;ages&#39;]] ## [1] 12 10 d[[2]] # usually not recommended ## [1] 12 10 Typically, though, data frames are created by reading in a data set from a file or a database, as we saw in the previous days of the workshop. Contrary to lists, data frames require their columns to be of the same length. If they are not, values will be recycled. That is why the following works: tibble(kids = c(&quot;Jack&quot;, &quot;Jill&quot;), ages = c(12, 10), type = &quot;kid&quot;) ## # A tibble: 2 x 3 ## kids ages type ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Jack 12 kid ## 2 Jill 10 kid 5.2 Introduction to Functions As in most programming languages, the heart of R programming consists of writing functions. A function is a group of instructions that takes inputs, uses them to compute other values, and returns a result. Let’s write a function that divides all elements of a vector by 2: half &lt;- function(x) { x / 2 } This is a function named half, whose purpose is to divides every element of a vector by 2. It’s a pretty pointless function, as the operation itself is so simple. Arguments to a function are enclosed by parentheses (()); the body of the function is enclosed by braces ({}). Let’s see how it works: half(c(3, 2, 1)) ## [1] 1.5 1.0 0.5 half(AirPassengers) ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov ## 1949 56.0 59.0 66.0 64.5 60.5 67.5 74.0 74.0 68.0 59.5 52.0 ## 1950 57.5 63.0 70.5 67.5 62.5 74.5 85.0 85.0 79.0 66.5 57.0 ## 1951 72.5 75.0 89.0 81.5 86.0 89.0 99.5 99.5 92.0 81.0 73.0 ## 1952 85.5 90.0 96.5 90.5 91.5 109.0 115.0 121.0 104.5 95.5 86.0 ## 1953 98.0 98.0 118.0 117.5 114.5 121.5 132.0 136.0 118.5 105.5 90.0 ## 1954 102.0 94.0 117.5 113.5 117.0 132.0 151.0 146.5 129.5 114.5 101.5 ## 1955 121.0 116.5 133.5 134.5 135.0 157.5 182.0 173.5 156.0 137.0 118.5 ## 1956 142.0 138.5 158.5 156.5 159.0 187.0 206.5 202.5 177.5 153.0 135.5 ## 1957 157.5 150.5 178.0 174.0 177.5 211.0 232.5 233.5 202.0 173.5 152.5 ## 1958 170.0 159.0 181.0 174.0 181.5 217.5 245.5 252.5 202.0 179.5 155.0 ## 1959 180.0 171.0 203.0 198.0 210.0 236.0 274.0 279.5 231.5 203.5 181.0 ## 1960 208.5 195.5 209.5 230.5 236.0 267.5 311.0 303.0 254.0 230.5 195.0 ## Dec ## 1949 59.0 ## 1950 70.0 ## 1951 83.0 ## 1952 97.0 ## 1953 100.5 ## 1954 114.5 ## 1955 139.0 ## 1956 153.0 ## 1957 168.0 ## 1958 168.5 ## 1959 202.5 ## 1960 216.0 here we are saving the output in a variable inside the function: half &lt;- function(x) { z &lt;- x / 2 z } An R functions will return the last value computed if there is no explicit return() call. We could have been more explicit, but it is usually not necessary: half &lt;- function(x) { z &lt;- x / 2 return(z) } Let’s make it a bit more complex, by adding an additional argument: fraction &lt;- function(x, denominator){ x / denominator } fraction(c(2, 3, 4), 4) ## [1] 0.50 0.75 1.00 if you have more than one argument, it is a good practice to name the arguments fraction(x = c(2, 3, 4), denominator = 4) ## [1] 0.50 0.75 1.00 that way, they become independent of the order, which is a very useful if the number of argument becomes large. fraction(denominator = 4, x = c(2, 3, 4)) ## [1] 0.50 0.75 1.00 5.2.1 Variable Scope A variable that is visible only within a function body is said to be local to that function. In square(), x is a local variable. In fraction(), x and p are local variables. They disappear after the function returns: fraction(x = c(2, 3, 4), denominator = 4) ## [1] 0.50 0.75 1.00 # denominator # Error: object &#39;denominator&#39; not found x ## $u ## [1] 2 3 4 ## ## $v ## [1] &quot;abc&quot; Note that the x is not the x we used in the fraction function, but rather the x defined earlier. x here is called a global variable, while the x in the function is a local variable. Global variables are shown in RStudio in the environment pane. A global variable can be written to from within a function by using R’s superassignment operator, &lt;&lt;-, but this is rarely recommended. 5.2.2 Default Arguments A nice feature of R functions is that you can set defaults to arguments. Let’s modify the fraction function from above: fraction &lt;- function(x, denominator = 2) { x / denominator } Here denominator will be initialized to 2 if the user does not specify p in the call. So we can use fraction() the same way as half(): fraction(c(2, 2)) ## [1] 1 1 half(c(2, 2)) ## [1] 1 1 or use its extended capabilities: fraction(c(2, 2), 3) ## [1] 0.6666667 0.6666667 5.2.3 Exercises Write a function add_constant that adds a constant to a vector, and set the default value of the constant to 10. Apply it to the AirPassengers series. You can use your function within dplyr. Using the mpg dataset, use add_constant within mutate to add a constant value (100) to the number of cyl. (evil) We saw that \"+\" is actually a function. In R, it is easily possible to change the working of such a fundamental function (this is, in fact, what ggplot does). In order to do so, let’s write a new function with the same name, \"+\", and two arguments, a, and b. But instead of summing the values, let’s subtract them (or figure out something more evil). Verify the result of 1 + 1. Cool, isn’t it? (rm(\"+\") will restore sanity.) 5.3 Higher-Order Functions Because functions in R are objects like any other objects, it is easy to write functions that return functions or take functions as arguments. We saw some examples above. The most prominent of these functions are higher-order functions, which are very central to R. They are called apply or lapply, or similar, and there are many of them. To avoid too much confusion, we will restrict ourself to map, the tidyverse equivalent of lapply, 5.3.1 map The map function ‘maps’ a function to each component of a list. Because lists are such a useful container for objects in R, very often, you want to map a function to each component of a list. Here is an example: ll &lt;- list(a = c(2, 3, 4), b = c(1, 2, 3), c = c(5, 2, 1)) This is a list with three vectors, of which we want to calculate the means. Here’s an expression that does what we want (we will cover loops later on): z &lt;- NULL for (vi in ll){ z &lt;- c(z, mean(vi)) } We loop through each component of the list, calculate the mean and add it to an output vector, z. With the map function, this can be written much more concise: library(tidyverse) map(ll, mean) ## $a ## [1] 3 ## ## $b ## [1] 2 ## ## $c ## [1] 2.666667 So map returns a list of the same length as the first argument (a list), each element of which is the result of applying the second argument (a function) to the corresponding component of the list argument. If the input list is named (as in the example), so will be the output. Additional arguments to the mean() function can be included as well: map(ll, mean, na.rm = TRUE) ## $a ## [1] 3 ## ## $b ## [1] 2 ## ## $c ## [1] 2.666667 If you want to convert the list to a vector (as in the loop example), use unlist on the result: unlist(map(ll, mean)) ## a b c ## 3.000000 2.000000 2.666667 Of course, you can use map with your own functions. Here we want to pick the second element of each vector in the list: pick_second &lt;- function(x){ x[2] } map(ll, pick_second) ## $a ## [1] 3 ## ## $b ## [1] 2 ## ## $c ## [1] 2 In cases like this, we may want to use the possibility of having anonymous functions, i.e. functions without a name. So we just substitute pick_second by its definition: map(ll, function(x) x[2]) ## $a ## [1] 3 ## ## $b ## [1] 2 ## ## $c ## [1] 2 For simple one line functions like this, it may be justified to omit the curly braces. ### Exercises Use map to calculate the mean of each variable in the swiss dataset. Convert the resulting list to a vector. Use map to coerce the variables in the swiss dataset to character. Using map, generate a list containing 10 random vectors of random length between 1 and 10. Use the help to see what the colSums() function does. Using apply, try writing your own version, colSums2(). 5.3.2 Loops In many programming languages, one of first things you learn are loops. There is a reason that we didn’t cover them until now, and also only for completeness. Loops in R are slow, and they are – most of the time – unnecessary. This is because many operations in R are vectorized anyway, so there is no need to loop over each element. Also the group_by() operation in dplyr offers a much more elegant way of applying a function repeatedly to a group of data. Third, there are higher order functions like map (or the tidyverse equivalent: purrr::map) that save you from loops most of the time. Anyway, here is the loop: for (i in 1:10) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 There will be one iteration of the loop for each component of the vector 1:10, with i taking on the values of those components – in the first iteration, i = (1:10)[1]; in the second iteration, i = (1:10)[2]; and so on. And we are not restricted to integer vectors, but can loop over any vector, even over lists: z &lt;- NULL for (i in list(swiss, mtcars)) { z &lt;- c(z, colnames(i)) } z ## [1] &quot;Fertility&quot; &quot;Agriculture&quot; &quot;Examination&quot; ## [4] &quot;Education&quot; &quot;Catholic&quot; &quot;Infant.Mortality&quot; ## [7] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; ## [10] &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; ## [13] &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; ## [16] &quot;gear&quot; &quot;carb&quot; But we saw a much clearer way of doing this above: unlist(map(list(swiss, mtcars), colnames)) ## [1] &quot;Fertility&quot; &quot;Agriculture&quot; &quot;Examination&quot; ## [4] &quot;Education&quot; &quot;Catholic&quot; &quot;Infant.Mortality&quot; ## [7] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; ## [10] &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; ## [13] &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; ## [16] &quot;gear&quot; &quot;carb&quot; "]
]
